---
title: "\"Intro to Shiny\" Workshop"
author: "Chris Payne"
date: "May 3, 2017"
output:  html_document
runtime: shiny
---
<style type="text/css">
  .main-container {
    max-width: 940px !important; 
  }
blockquote {
  font-size: 13px
}
h1.title {
  font-size: 55px;
  font-family: "Arial MT";
  text-align: center;
}
h4.author { 
  font-size: 25px;
  font-family: "Arial MT";
  text-align: center;
}
h4.date { 
  font-size: 25px;
  font-family: "Arial MT";
  text-align: center;
}
body {
  font-family: "Arial MT";
}
}
/* Headers */
h1,h2,h3,h4,h5,h6{
  font-family: "Arial MT";
}
</style>

```{r, messages = FALSE,echo=FALSE}
setwd("C:/Users/Chris/Stuff/UNC/Conferences/UNC/UNC Biology/Shiny Workshop - 2017/")
```

***

# **Shiny**

<div style = "font-size:2px;" >
&nbsp;
</div>

[Shiny](https://shiny.rstudio.com/) is an R package that allows you to create interactive components (e.g., plots) that can be displayed as an html app.   
Shiny offers two unique features:

 - Contains commands for taking in user input from an HTML user interface
 - Updates plots automatically when user input changes.
 
Shiny apps have 2 main components: 

 1. User-interface (**UI**) script 
 2. **Server** script
 
The **User-interface script** (which can be saved as ui.R) controls the layout and appearance of the app/web-page.

 - It will include Shiny-specific commands such as `sidebarLayout()`, `mainPanel()`, etc.

The **Server script** (server.R) has the R code needed to actually *build* the app.

<div style = "font-size:4px;" >
&nbsp;
</div>

<div style = "font-size:12px;" >
 **Note**: Although earlier versions of Shiny required that the UI and Server scripts were separate .R files, current versions allow for all code to be in a single .R file. 

 - For convenience sake, however, I will still refer to these "sections" as **ui.R** and **server.R**.
 
 </div>
 
<div style = "font-size:2px;" >
&nbsp;
</div>

### **Getting Started**

<div style = "font-size:2px;" >
&nbsp;
</div>

The first step is to install the Shiny package.

```{r, message=FALSE,results="hide",warning=FALSE,eval=FALSE,chunk_title="load"}
install.packages("shiny", repos="http://cran.rstudio.com/")
library(shiny)
```

<div style = "font-size:4px;" >
&nbsp;
</div>

If you didn't believe me before, here is the simplest working Shiny app:

```{r, message=FALSE, warning=FALSE,eval=FALSE,chunk_title="Simple_Shiny"}
ui <- fluidPage()
server <- function(input, output){}
shinyApp(ui = ui, server = server)
```

Note: it's completely blank (but error free!).
We can **use it as a template to build additional apps**.

<div style = "font-size:4px;" >
&nbsp;
</div>

#### **Simple Example**

<div style = "font-size:2px;" >
&nbsp;
</div>

Shiny has a few built-in examples to show you its capabilities. We'll start by looking at a histogram that's made interactive by allowing you to change the number of bins. Let's review the code to generate a histogram.

```{r, chunk_title="Intro to Histograms",fig.align="center"}
x <- faithful$waiting ## waiting times using internal dataset "faithful"
bins <- seq(min(x), max(x), length.out=20+1)
hist(x, breaks=bins, col="darkgray", border="white", 
     main="Old faithful waiting time to next eruption", xlab="Minutes")
```

We can change the bins manually by increasing/decreasing the number of breaks, but Shiny allows the user to change the number of bins in *real-time*. The following code runs/opens this interactive example (which also conveniently provides its source code for demonstration).

```{r, eval=FALSE,warning=FALSE,chunk_title="Shiny_Example"}
library(shiny)
runExample("01_hello")
```

```{r, eval=TRUE,echo=FALSE,fig.align="center",chunk_title="Shiny_Example-works"}

## Note: for some reason the runExample function (above code chunk) doesn't seem to want to work in the R Markdown doc. This is detailed in this Stack Overflow question I opened: http://stackoverflow.com/q/43394920/4581200
## I've created a working solution which I'll copy here.
## Note: echo=FALSE so that this code never appears to the readers, but instead simply generates the shiny app output the above runExample code is supposed to generate (when it's assigned eval=TRUE).

## Note: I have to (re)assign the resolve() function (and its internal isWindows() function) because for some reason when I run the runExample2 code without doing so, I get the error "could not find function 'resolve'"

library(shiny)

isWindows <- function () 
.Platform$OS.type == "windows"

resolve <- function (dir, relpath) 
{
    abs.path <- file.path(dir, relpath)
    if (!file.exists(abs.path)) 
        return(NULL)
    abs.path <- normalizePath(abs.path, winslash = "/", mustWork = TRUE)
    dir <- normalizePath(dir, winslash = "/", mustWork = TRUE)
    if (isWindows()) 
        dir <- sub("/$", "", dir)
    if (nchar(abs.path) <= nchar(dir) + 1) 
        return(NULL)
    if (substr(abs.path, 1, nchar(dir)) != dir || substr(abs.path, 
        nchar(dir) + 1, nchar(dir) + 1) != "/") {
        return(NULL)
    }
    return(abs.path)
}


runExample2 <- function (example = NA,...) 
{
    examplesDir <- system.file("examples", package = "shiny")
    dir <- resolve(examplesDir, example)
    if (is.null(dir)) {
        if (is.na(example)) {
            errFun <- message
            errMsg <- ""
        }
        else {
            errFun <- stop
            errMsg <- paste("Example", example, "does not exist. ")
        }
        errFun(errMsg, "Valid examples are \"", paste(list.files(examplesDir), 
            collapse = "\", \""), "\"")
    }
    else {
        shinyAppDir(appDir = dir,...)
    }
}


runExample2("01_hello",options = list(height = 470))
```

<div style = "font-size:1px;" >
&nbsp;
</div>

This example app uses the input from the user (number of bins), and the `renderPlot()` function to allow the plot to update automatically.

*** 

### **Let's Walk Through a More Thorough Example:**

<div style = "font-size:2px;" >
&nbsp;
</div>

#### **The Data: **

<div style = "font-size:2px;" >
&nbsp;
</div>

We'll be using the **CO2** data set that comes default with R. (note: use `data()` to see a list of all available datasets).

 - The [CO2 data set](https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/zCO2.html) (84 rows, 5 columns) comes from an experiment on the cold tolerance of the grass species *Echinochloa crus-galli*.

 - Experiment: CO$^2$ uptake of 12 plants (6 each from Quebec and Mississippi) was measured at several levels of ambient CO$^2$ concentration. Half the plants of each type were chilled overnight before the experiment was conducted.
 
  - Let's examine the structure of the data:

```{r message=FALSE,results="hide",warning=FALSE,max.print=6,chunk_title="str(CO2)" }
str(CO2)
```

I've chosen this data set because it's complex enough to use as a thorough example but simple enough for everyone to (hopefully) follow along. 

For convenience sake, I'm going to rename the CO2 data set as **`dat`** while simultaneously creating a numeric ID# for each unique plant:

```{r}
dat <- data.frame(ID = as.numeric((CO2$Plant)),CO2)
```

<div style = "font-size:4px;" > &nbsp; 
</div>

#### **Start with a Basic App:**

<div style = "font-size:2px;" >
&nbsp;
</div>

We'll start with a scatter plot showing CO$^2$ uptake as a function of CO$^2$ concentration. Our app will be able to control which points are included in the plot based on the plants' `Type` argument. 

<div style = "font-size:2px;" >
&nbsp;
</div>

##### **UI.R:**

```{r, eval=TRUE}
ui <- fluidPage(  ## creates display that auto adjusts to user's device dimensions
  # Main title
  titlePanel("Shiny Workshop Example - CO2 Uptake in Plants"),
  # Establish sidebar layout:
  sidebarLayout(
    # Create sidebar (which we'll fill with input controls)
    sidebarPanel(
      # Create a check box input control allowing multiple items to be checked
      checkboxGroupInput(inputId = "type", label = "Plant Type", choices = levels(dat$Type), 
                         selected = levels(dat$Type))  
                         ## Note: levels() shows all unique "names" of a class = factor object
    ),
    # Spot for the plot
    mainPanel(
      plotOutput(outputId = "scatter.plot")  ## "scatter.plot" output object is created in server.R
    )
))
```

<div style = "font-size:2px;" >
&nbsp;
</div>

##### **Server.R:**

```{r, eval=TRUE}
server <- function(input, output) {

  # renderPlot indicates that the function is "reactive" - it will automatically re-execute when input changes
  output$scatter.plot <- renderPlot({
    
    # Render the plot:    
    ## We'll create a stable plot size based on all data before adding [changing] subsets using points().
    plot(uptake ~ conc, data = dat, type = "n")  ## type = "n" causes no points to be drawn.
    points(uptake ~ conc, data = dat[dat$Type  %in% c(input$type),])
    title(main = "Plant Trends")
    })
}
```

<div style = "font-size:2px;" >
&nbsp;
</div>

Now combine the `UI` code and the `Server` code into a working app:

```{r, echo=TRUE,eval=FALSE}
shinyApp(ui = ui, server = server)
```

<div style = "font-size:2px;" >
&nbsp;
</div>

```{r, echo=FALSE,eval=TRUE,fig.align="center"}
##I copied this code from above (this time with eval=T,echo=F) in order to increase the height of the output shiny app (to eliminate the need for a height scroll bar when viewing).
##I do it this way so that I can adjust the height of the output without including the "options" code in the shiny code text. (This is because the options argument is important for my r markdown doecument, not in the actual hsiny code)
shinyApp(ui = ui, server = server,options = list(height = 470))
```

In this example, we can choose to select which "plant type"" we view in the plot. 

 - This is accomplished by sub-setting `dat` by rows in which `dat$Type` equals whichever type we have checked in our sidepanel (provided by `input$type`). 
 
<div style = "font-size:2px;" >
&nbsp;
</div>
 
***
 
##### **Three Things to Note:**

<div style = "font-size:2px;" >
&nbsp;
</div>

  1. Code structuring in both scripts
  
    - Each object of code in ui.R acts as an argument of `fluidPage`. As a result, each of these arguments *needs* to be **separated by a comma**.

    - Code in server.R functions just like normal R code (with the addition of reactive objects), and therefore separate chunks of code do not need to be separated in any unique way.
    
  2. The use of `{ }` in server.R
  
    - Just like when creating custom functions or for-loops in R, we use `{ }` inside reactive functions to denote that everything within those brackets *can* be changed based on changing inputs. 
    
        - Like functions and loops, you can put endless code within the brackets with the final object being the "main" output of the reactive function. 
      
        - Note that not all code within these reactive functions (i.e., within the curly brackets) needs to be directly impacted by inputs. 

  3. Inputs and Outputs:
  
    - All manipulative inputs (i.e., the results of `input()` functions) are assigned an **inputID** in ui.R, which are referenced in server.R as `input$inputId`.
  
    - All outputs we wish to view in the App are assigned as `output$outputId` using a `render*()` function in server.R. These outputs are referenced with their **outputId** in `output()` functions in ui.R. 
    
```{r ,echo=FALSE,fig.width=4,fig.height=3.25,fig.align="center"}
library(png)
library(grid)
img <- readPNG("C:/Users/Chris/Stuff/UNC/Conferences/UNC/UNC Biology/Shiny Workshop - 2017/ShinyGeneralWorkflow.PNG")
grid.raster(img)
```
    
***

<div style = "font-size:2px;" >
&nbsp;
</div>

#### **We'll Progressively Make This App More Complex...**

<div style = "font-size:2px;" >
&nbsp;
</div>

##### **First, Let's Add Some Styling:**

<div style = "font-size:2px;" >
&nbsp;
</div>

HTML styling occurs as arguments within [tags](https://shiny.rstudio.com/articles/tag-glossary.html) (or [tag helper functions](https://shiny.rstudio.com/articles/html-tags.html)) and takes the form of: `style = "property:value;"` 

 - Where different `property:value` combos are separated by semicolons and all combos are held within quotes.

 - Styles can be added directly to .R script in numerous ways:

     1. Inline (within tag or tag helper function): `p("Some Text", style = "font-size: 15px; color:blue;")`
 
     2. Applied to whole sections: `div(style = "color:green; padding:10px 0px 10px 0px;",...code to apply to...)`
     
<div style = "font-size:2px;" >
&nbsp;
</div>     
     
```{r ,echo=TRUE,results="hide",eval=TRUE,fig.align="center"}
ui <- fluidPage(  ## creates display that auto adjusts to user's device dimensions
  # Main title
  titlePanel(
    ## paragraph of size-20 text: 
    p("Shiny Workshop Example - CO2 Uptake in Plants", style = "font-size: 20px")), 
  # Establish Sidebar layout:
  sidebarLayout(
    # Create sidebar (which we'll fill with input controls)
    sidebarPanel(width = 3,
      div(style = "color:green; padding:0px 0px 150px 0px;", #padding is top, right, bottom, left
        checkboxGroupInput(inputId = "type", label = "Plant Type", choices = levels(dat$Type), 
                           selected = levels(dat$Type))
        ) ## Everything held within this div() tag helper function will take on the styles assigned to it 
          ## (Unless overridden internally) -- see next code example
      ),
    # Spot for the plot
    mainPanel(width = 9,
      plotOutput(outputId = "scatter.plot")
    )
))

server <- function(input, output) {

  # renderPlot indicates that the function is "reactive" - it will automatically re-execute when input changes
  output$scatter.plot <- renderPlot({
    
    # Render the plot:    
    ## We'll create a stable plot size based on all data before adding [changing] subsets using points().
    plot(uptake ~ conc, data = dat, type = "n")  ##type = "n" causes no points to be drawn.
    points(uptake ~ conc, data = dat[dat$Type  %in% c(input$type),])
    title(main = "Plant Trends")
    })
}

shinyApp(ui = ui, server = server)
```

```{r, echo=FALSE,eval=TRUE,fig.align="center"}
##I copied this code from above (this time with eval=T,echo=F) in order to increase the height of the previous output shiny app (to eliminate needing a height scroll bar when viewing).
shinyApp(ui = ui, server = server,options = list(height = 470))
```

<div style = "font-size:2px;" >
&nbsp;
</div>

We've reduced the font size of the title, changed the color of the text in the sidebarPanel and extended the lower edge of the sidepanel by 150 pixels. Note that all of these changes occurred in the ui code only, and the server code remains unchanged. 

You'll also notice we added `width` arguments to the two panels in our sidebarLayout. This caused the widths of our side panel and main panel to change (shrink and grow, respectively). 

**FluidPage windows are split width-wise into 12 units**. These are essentially unit-less and instead represent relative proportions of the flexible screen width. (Remember, fluidPage allows the app to fit numerous screen sizes). 

 - The arbitrary 12-unit width applies to all sub-setted layers as well. So even though the whole screen can be assigned 1 to 12 units of width, each panel can likewise itself be split-up based on a 12-unit scale. 

    - If we wanted to subset either panel further, we would use `fluidRow` and `column` functions with their own assignments of `widths` (as well as `offsets` for spaces).
    
<div style = "font-size:2px;" >
&nbsp;
</div>    
    
##### **Next, Let's Add More Input Controls!**

<div style = "font-size:2px;" >
&nbsp;
</div>

Next, we'll add a number of other input controls that can each modify our plot. These will help to demonstrate [only some of] the myriad of input [widgets](https://shiny.rstudio.com/gallery/widget-gallery.html) available in shiny. 

We'll simultaneously demonstrate **how one can split up an app's panel using `fluidRow` and `column` arguments**. 

 - Specifically, `fluidRow` must be called anytime you want to isolate adjustment to a given row as well any time you want to add objects side by side. This latter case is when you apply the `column` function.
 
<div style = "font-size:2px;" >
&nbsp;
</div>   

``` {r ,echo=TRUE,results="hide",eval=TRUE,fig.align="center"}
ui <- fluidPage(
  
  # Title Panel: ####
  titlePanel(
    p("Shiny Workshop Example - CO2 Uptake in Plants", style = "font-size: 20px")
  ),
  
  
  sidebarPanel(width = 3,
               div(style = "color:green; padding:0px 0px 150px 0px;", #padding is top, right, bottom, left
                   p("Data Controls", style = "font-size: 15px; color:blue;"),           

                   # Check box to give us the option whether to show all plants... 
                   # ...or just the plant selected in the slider input below
                     checkboxInput(inputId = "all.plants", label = "Show All Plants", value = T),

                   # Slider bar allows us to select which plant ID to plot.
                   # This slider only works if the above checkboxInput is unchecked (see server.R code).
                     sliderInput(inputId = "plant", label = "Plant ID", min = min(dat$ID), max = max(dat$ID),
                                 value = 1),  ## sets starting value at 1

                   # This group check box let's us narrow which plant Types are plotted.
                   # checkboxGroupInput differs from checkboxInput by allowing more than one to be checked.
                     checkboxGroupInput(inputId = "type", label = "Plant Type", choices = levels(dat$Type), 
                                        selected = levels(dat$Type)), ## sets starting checks to all levels 

                   # Radio buttons work like checkboxes, but result in strings/#'s instead of boolean T/F. 
                   # They allow multiple options like checkboxGroupInputs, but only one selection. 
                     radioButtons(inputId = "treat", label = "Treatment", 
                                  choices = c(levels(dat$Treatment), "Both"), selected = "Both"),

                   fluidRow(
                     div(style = "color:red;",
                         ## since both columns below are assigned a width of 6 (with 0 offset), 
                         ## they'll fill the tabpanel width equally.
                         column(width = 6, offset = 0,   
                                selectInput(inputId = "colorQ", label = "Quebec Color", choices = palette(), 
                                            selected = "black")
                         ),
                         column(width = 6, offset = 0,
                                selectInput(inputId = "colorM", label = "Miss. Color", choices = palette(), 
                                            selected = "black") 
                         )
                     )
                     
                   )
               ) ## Everything held within this div tag helper function takes on the styles assigned in div()
                 ## (Unless overridden internally) -- see the div() function assigned in fluidRow above. 
  ),

  #Spot for the plot  
  mainPanel(width = 9,
            plotOutput(outputId = "scatter.plot",click = "plot.click")
  )
)


server <- function(input, output) {
  
  # We need to Set-up various input values:

    ## Allows us to narrow data by one plant or to include all plants. 
    ## This is necessary b/c checkboxInput simply generates T/F, and we must translate that to plant ID #'s. 
    plants.to.plot <- reactive({ 
      if(input$all.plants == T) {
        sort(unique(dat$ID))
      } else { input$plant
      }
    })
  
    ## Allows us to narrow data by one treatment level or to include both. 
    ## This is necessary because "both" is not actually a Treatment type, ... 
    ## ...and therefore needs to be assigned something meaningful (i.e., relevant to the data)
    treats.to.plot <- reactive({ 
      if(input$treat == "Both") {
        levels(dat$Treatment)
      } else {input$treat
      }
    }) 
  
    ## provides vector of color options (corresponding to plant$Type) to apply to coloring points in plot
    colors <- reactive({
      Colors <- rep(NA,length(dat2()$Type))
      Colors[which(dat2()$Type == "Quebec")] <- input$colorQ
      Colors[which(dat2()$Type == "Mississippi")] <- input$colorM
      Colors
    })   
  
  # Create modified data set based on our numerous input selections:
  ## This will keep our plotting code neater...
  
  dat2 <- reactive({  dat[dat$ID %in% c(plants.to.plot()) &
                            dat$Type  %in% c(input$type) &
                            dat$Treatment %in% c(treats.to.plot()), ] 
  })
  

  # Create plot to be rendered in mainpanel. Notice we now use dat2 as the data source. 
  
  output$scatter.plot <- renderPlot({
    plot(uptake ~ conc, data = dat, type = "n")
    points(uptake ~ conc, data = dat2(),col = colors())
    title(main = paste0("Plant(s): ", paste(levels(dat$Plant)[plants.to.plot()],collapse =", ")))
     ## title combines "Plant(s)" with the plant names of whichever plants are included by the inputs. 
  })
}

## note that we can save a shinyApp as an object that, when called, runs the app automatically 
app <- shinyApp(ui = ui, server = server) 
app
```

```{r, echo=FALSE,eval=TRUE,fig.align="center"}
##I copied this code from above (this time with eval=T,echo=F) in order to increase the height of the previous output shiny app (to eliminate needing a height scroll bar when viewing).
shinyApp(ui = ui, server = server,options = list(height = 740))
```

<div style = "font-size:12px;" >
&nbsp;
</div>  

##### **One More Round of Complexity:**

<div style = "font-size:2px;" >
&nbsp;
</div> 

We'll update once more by including three more levels of complexity to our app. This will include introduction to two additional `render*()` and `*output()` functions.

 1. I'll demonstrate that the **main panel can** likewise **contain multiple objects (of different types)**.
 
     - We'll add a data table below the scatter plot using `renderDataTable()` and `dataTableOutput()`
 
 2. Similarly, I'll demonstrate that **output can be placed in the sidebarPanel**. 
 
     - We'll add reactive printed text using `renderPrint()` and `verbatimTextOutput()` (more on that in a minute).  
 
 3. I'll demonstrate one of **many ways to add multiple "pages" (in this case *tabs*)** to your Shiny app. )
 
     - Specifically, we'll add navigable tab panels using the `tabsetPanel()` function so as to extend our app to more pages.

<div style = "font-size:2px;" >
&nbsp;
</div> 

Before we run this new code chunk, I want to introduce a cool functionality of `plotOutput()`. If you examine the help page for `plotOutput()` you'll see the arguments `click`, `dblclick`, `hover` etc. As you might be able to guess, these arguments **allow reactivity when clicking or hovering your mouse over plots** in the UI. 

 - One application of this is to click on a point in a plot and have that point's data reported to you. This can be done in a couple of ways, but I'll demonstrate the function **`nearPoints`**. From R documentation: 
 
    > This function returns rows from a data frame which are near a click, hover, or double-click, when used with plotOutput. The rows will be sorted by their distance to the mouse event. 

<div style = "font-size:4px;" >
&nbsp;
</div> 
    
Ok, on to the next code chunk: 

``` {r, echo=TRUE,results="hide",eval=TRUE,fig.align="center"}
library(shiny)

ui <- fluidPage(
  
  # Title Panel: ####
  titlePanel(
    p("Shiny Workshop Example - CO2 Uptake in Plants", style = "font-size: 20px")
  ),
  
  sidebarPanel(width = 3,
               div(style = "color:green; padding:0px 0px 150px 0px;", #padding is top, right, bottom, left
                   p("Data Controls", style = "font-size: 15px; color:blue;"),           
                   
                   # Check box to give us the option whether to show all plants 
                   # or just the plant selected in the slider input below
                   checkboxInput(inputId = "all.plants", label = "Show All Plants", value = T),
                   
                   # Slider bar allows us to select which plant ID to plot
                   # This slider only works if the above checkboxInput is unchecked (see server.R code)
                   sliderInput(inputId = "plant", label = "Plant ID", min = min(dat$ID), max = max(dat$ID),
                               value = 1),  ## sets starting value at 1
                   
                   # This group check box let's us narrow which plant Types are plotted.
                   # checkboxGroupInput differs from checkboxInput by allowing more than one to be checked
                   checkboxGroupInput(inputId = "type", label = "Plant Type", choices = levels(dat$Type), 
                                      selected = levels(dat$Type)), ## sets starting checks to all levels 
                   
                   # Radio buttons work like checkboxes, but result in strings/#'s instead of boolean T/F. 
                   # They allow multiple options like checkboxGroupInputs. 
                   radioButtons(inputId = "treat", label = "Treatment", 
                                choices = c(levels(dat$Treatment), "Both"), selected = "Both"),
                   
                   fluidRow(
                     div(style = "color:red;",
                         column(width = 6, offset = 0,
                                selectInput(inputId = "colorQ", label = "Quebec Color", choices = palette(), 
                                            selected = "black")
                         ),
                         column(width = 6, offset = 0,
                                selectInput(inputId = "colorM", label = "Miss. Color", choices = palette(), 
                                            selected = "black") 
                         )
                     )
                   ),
                   
                   ## We'll insert printed R output generated from clicking the plot
                   ## Note: this text is created using nearPoints() in server.R
                   verbatimTextOutput(outputId = "plot.info")
                   
               )
  ),
  
  mainPanel(width = 9,
            
            ## Create tab layout for our app
            ## Note b/c of placement, we will keep side bar consistent, but have changing mainpanel content
            tabsetPanel( 
              
              ## Everything held within this argument will be placed in a tab with title "Scatter Plot"
              tabPanel(title = "Scatter Plot", 
                       
                       plotOutput(outputId = "scatter.plot",click = "plot.click"),
                       ## Note: we've assigned a new input object called "plot.click"
                       
                       ##Let's add a data table to our main panel below the graph. 
                       ## (Note: don't forget to add a comma after `plotOutput()`)
                       dataTableOutput(outputId = "data") 
                       
              ),
              
              tabPanel(title = "Tab 2",
                       p("We can add another graph here!!",style = "font-size:38px;" )
                       
              )
            )
  )
)


server <- function(input, output) {
  
  # We need to Set-up various input values:

    ## Allows us to narrow data by one plant or to include all plants. 
    ## This is necessary b/c checkboxInput simply generates T/F, and we must translate that to plant ID #'s. 
    plants.to.plot <- reactive({ 
      if(input$all.plants == T) {
        sort(unique(dat$ID))
      } else { input$plant
      }
    })
  
    ## Allows us to narrow data by one treatment level or to include both. 
    ## This is necessary because "both" is not actually a Treatment type, ... 
    ## ...and therefore needs to be assigned something meaningful (i.e., relevant to the data)
    treats.to.plot <- reactive({ 
      if(input$treat == "Both") {
        levels(dat$Treatment)
      } else {input$treat
      }
    }) 
  
    ## provides vector of color options (corresponding to plant$Type) to apply to coloring points in plot
    colors <- reactive({
      Colors <- rep(NA,length(dat2()$Type))
      Colors[which(dat2()$Type == "Quebec")] <- input$colorQ
      Colors[which(dat2()$Type == "Mississippi")] <- input$colorM
      Colors
    })   
  
  # Create modified data set based on our numerous input selections:
  ## This will keep our plotting code neater...
  
  dat2 <- reactive({  dat[dat$ID %in% c(plants.to.plot()) &
                            dat$Type  %in% c(input$type) &
                            dat$Treatment %in% c(treats.to.plot()), ] 
  })
  

  # Create plot to be rendered in mainpanel. Notice we now use dat2 as the data source. 
  
  output$scatter.plot <- renderPlot({
    plot(uptake ~ conc, data = dat, type = "n")
    points(uptake ~ conc, data = dat2(),col = colors())
    title(main = paste0("Plant(s): ", paste(levels(dat$Plant)[plants.to.plot()],collapse =", ")))
     ## title combines "Plant(s)" with the plant names of whichever plants are included by the inputs. 
  })

    
  # Create data.frame showing data of only the plants (i.e. the rows) selected to be plotted
  
  output$data <- renderDataTable({ dat2()},
                                 options = list(lengthMenu = list(c(5, 10,-1), list("5", "10", "All")), 
                                                pageLength = 5, ordering = T))
                                 ## These options allow for modification of the data table presented.
                                 ## This is a rare case in which UI formatting is assigned in server.R code
                                   ## lengthMenu creates drop down menu giving you choice in # of rows to show.
                                      ## (-1 = show all rows)
                                   ## pageLength assigns how many rows are shown when table is 1st rendered
                                   ## ordering allows you to click on columns to change ordering of the data.
  
  
  # Create data to be generated when the scatter plot is clicked 
  
    ## Note: input$plot.click is generated by clicking on the scatter plot. 
    ## This plot-click input object provides x & y coordinates of where you click 
  
    ## We could use the nearPoints function to do this, but I don't like that it has a "messy" NULL output
  
       #output$plot.info <- renderPrint({
         #nearPoints(dat2()[,2:6], input$plot.click, xvar = "conc", yvar = "uptake",threshold=3)})
  
    ## Instead, I'll make my own function that provides a custom string of text when nothing is clicked. 

       #Update to make plot clicker info look better:
       nearPoints2 <- function(coordinfo,blank.text = "Click on Plot Points for Details", cols, ...) {
         if (is.null(coordinfo)) {
           cat(blank.text,"\n")   #"Click on Plot Points for Details"
           } else { 
             points.info.table <- nearPoints(coordinfo = coordinfo,...)
             print(points.info.table[,cols], row.names = F)
             }
       }
  
       #Create table containing columns 2:6 of dat2 for the point clicked and assign to renderPrint output:
         output$plot.info <- renderPrint({
           nearPoints2(coordinfo = input$plot.click, cols = c(2:6), df = dat2(), xvar = "conc", 
                       yvar = "uptake",threshold=3)
         })  ## Note: nearPoints (default or nP2) actually reports all points (i.e., rows in your data.frame)  
             ## that are within the threshold value distance from your click. 
             ## So you might want to shrink `threshold` if your clicks result in too many data.
}

app <- shinyApp(ui = ui, server = server)
app
```

```{r, echo=FALSE,eval=TRUE,fig.align="center"}
##I copied this code from above (this time with eval=T,echo=F) in order to increase the height of the previous output shiny app (to eliminate needing a height scroll bar when viewing).
shinyApp(ui = ui, server = server,options = list(height = 890))
```

<div style = "font-size:4px;" >
&nbsp;
</div> 

***

<div style = "font-size:2px;" >
&nbsp;
</div>

### **Now It's Your Turn!**

<div style = "font-size:2px;" >
&nbsp;
</div>

Can you generate the app demonstrated below? 

<div style = "font-size:8px;" >
&nbsp;
</div> 

``` {r, eval=TRUE,fig.align="center",echo=FALSE}
library(shiny)

dat <- data.frame(ID = as.numeric((CO2$Plant)),CO2)

ui <- fluidPage(
  
  # Title Panel: 
  titlePanel(
    p("Shiny Workshop Example - CO2 Uptake in Plants", style = "font-size: 20px")
  ),
  
  ## we must move the tabsetPanel (and subsequent tabPanel) functions before the sidebarPanel... 
  ## ...in order to have changing sidePanels.
  ## (If we wanted different titles, we place titlePanel inside tabsetPanel, too.)
  tabsetPanel( 
    tabPanel(title = "Scatter Plot",
             
             sidebarPanel(width = 3,
                          div(style = "color:green; padding:0px 0px 150px 0px;", 
                              #padding is top, right, bottom, left
                              
                              p("Data Controls", style = "font-size: 15px; color:blue;"),           
                              
                              # Check box to give us the option whether to show all plants... 
                              # ...or just the plant selected in the slider input below
                              checkboxInput(inputId = "all.plants", label = "Show All Plants", value = T),
                              
                              # Slider bar allows us to select which plant ID to plot
                              # This slider only works if the above checkboxInput is unchecked (see server.R)
                              sliderInput(inputId = "plant", label = "Plant ID", min = min(dat$ID), 
                                          max = max(dat$ID), value = 1),  ## sets starting value at 1
                              
                              # This group check box let's us narrow which plant Types are plotted.
                              # checkboxGroupInput differs from checkboxInput by allowing more than one check
                              checkboxGroupInput(inputId = "type", label = "Plant Type", choices = 
                                                   levels(dat$Type), selected = levels(dat$Type)),  
                              
                              # Radio buttons work like checkboxes, but result in strings/#'s instead of T/F. 
                              # They allow multiple options like checkboxGroupInputs. 
                              radioButtons(inputId = "treat", label = "Treatment", 
                                           choices = c(levels(dat$Treatment), "Both"), selected = "Both"),
                              
                              fluidRow(
                                div(style = "color:red;",
                                    column(width = 6, offset = 0,
                                           selectInput(inputId = "colorQ", label = "Quebec Color", 
                                                       choices = palette(), selected = "black")
                                    ),
                                    column(width = 6, offset = 0,
                                           selectInput(inputId = "colorM", label = "Miss. Color", 
                                                       choices = palette(), selected = "black") 
                                    )
                                )
                              ),
                              ## We'll insert printed R output generated from clicking the plot
                              ## Note: this text is created using nearPoints() in server.R
                              verbatimTextOutput(outputId = "plot.info")
                              
                          )
             ),
             
             mainPanel(width = 9,
                       plotOutput(outputId = "scatter.plot",click = "plot.click"), ## scatter plot
                       dataTableOutput(outputId = "data") ## data table 
             )
             
    ),
    
    ## Create 2nd tab:
    tabPanel(title = "Box Plot",
             
             ## Add subtitle using paragraph HTML tag helper function:
             p("Box Plot Viewer",style = "font-size:18px;"),
             
             ## Set up new sidebarPanel
             sidebarPanel(width = 3,
                          
                          ## Provide sidebarPanel title:
                          p("Box Plot Controls", style = "color:purple"),
                          
                          ## Add input selector to choose which x variable is plotted:
                          radioButtons(inputId = "box.plot.chooser", label = "X Variable", 
                                       choices = names(CO2)[names(CO2) != "uptake"], selected = "Type"),
                          
                          ## Add slider that controls at which y value a "moveable" horizontal line is located:
                          sliderInput(inputId = "box.slider", label = "Comparison Aid", min = 0, 
                                      max = max(CO2$uptake), value = 0)
                          
             ),
             ## Set up new mainPanel for this 2nd tab:
             mainPanel(width = 9,
                       plotOutput(outputId = "boxplot")
             )
    )
  )
)

server <- function(input, output) {
  
  # We need to Set-up various input values:
  
  ## Allows us to narrow data by one plant or to include all plants. 
  ## This is necessary b/c checkboxInput simply generates T/F, and we must translate that to plant ID #'s. 
  plants.to.plot <- reactive({ 
    if(input$all.plants == T) {
      sort(unique(dat$ID))
    } else { input$plant
    }
  })
  
  ## Allows us to narrow data by one treatment level or to include both. 
  ## This is necessary because "both" is not actually a Treatment type, ... 
  ## ...and therefore needs to be assigned something meaningful (i.e., relevant to the data)
  treats.to.plot <- reactive({ 
    if(input$treat == "Both") {
      levels(dat$Treatment)
    } else {input$treat
    }
  }) 
  
  ## provides vector of color options (corresponding to plant$Type) to apply to coloring points in plot
  colors <- reactive({
    Colors <- rep(NA,length(dat2()$Type))
    Colors[which(dat2()$Type == "Quebec")] <- input$colorQ
    Colors[which(dat2()$Type == "Mississippi")] <- input$colorM
    Colors
  })   
  
  # Create modified data set based on our numerous input selections:
  ## This will keep our plotting code neater...
  
  dat2 <- reactive({  dat[dat$ID %in% c(plants.to.plot()) &
                            dat$Type  %in% c(input$type) &
                            dat$Treatment %in% c(treats.to.plot()), ] 
  })
  
  
  # Create plot to be rendered in mainpanel. Notice we now use dat2 as the data source. 
  
  output$scatter.plot <- renderPlot({
    plot(uptake ~ conc, data = dat, type = "n")
    points(uptake ~ conc, data = dat2(),col = colors())
    title(main = paste0("Plant(s): ", paste(levels(dat$Plant)[plants.to.plot()],collapse =", ")))
    ## title combines "Plant(s)" with the plant names of whichever plants are included by the inputs. 
  })
  
  
  # Create data.frame showing data of only the plants (i.e. the rows) selected to be plotted
  
  output$data <- renderDataTable({ dat2()},
                                 options = list(lengthMenu = list(c(5, 10,-1), list("5", "10", "All")), 
                                                pageLength = 5, ordering = T))
                                ## These options allow for modification of the data table presented.
                                ## This is a rare case in which UI formatting is assigned in server.R code
                                  ## lengthMenu creates drop down menu giving you choice in # of rows to show.
                                     ## (-1 = show all rows)
                                  ## pageLength assigns how many rows are shown when table is 1st rendered
                                  ## ordering allows you to click on columns to change ordering of the data.
  
  
  # Create data to be generated when the scatter plot is clicked 
  
  #Update to make plot clicker info look better:
  nearPoints2 <- function(coordinfo,blank.text = "Click on Plot Points for Details", cols, ...) {
    if (is.null(coordinfo)) {
      cat(blank.text,"\n")   #"Click on Plot Points for Details"
    } else { 
      points.info.table <- nearPoints(coordinfo = coordinfo,...)
      print(points.info.table[,cols], row.names = F)
    }
  }
  
  #Create table containing columns 2:6 of dat2 for the point clicked and assign to renderPrint output:
  output$plot.info <- renderPrint({
    nearPoints2(coordinfo = input$plot.click, cols = c(2:6), df = dat2(), xvar = "conc", 
                yvar = "uptake",threshold=3)
  })
  
    ## Note: nearPoints (default or nP2) actually reports all points (i.e., rows in your data.frame)...  
    ## ...that are within the threshold value distance from your click. 
    ## So you might want to shrink `threshold` if your clicks result in too many data.  
  
  ###############
  
  ##Here is the added boxplot code. 
  
  output$boxplot <- renderPlot({
    
    ## I want the boxplot function to plot different x variables, which are input as character strings.
    ## Character strings need to be slightly modified to be included in a plotting function.
    ## One option: `boxplot(as.formula(paste("uptake",input$box.plot.chooser, sep = " ~ ")), data = CO2)`
    ## I instead choose to go with a "cleaner" approach:
    
    boxplot(CO2[,"uptake"] ~ CO2[,input$box.plot.chooser], xlab = input$box.plot.chooser, ylab = "uptake")
    lines(x = c(0:15), y = rep(input$box.slider,16), lty = 6)  
    ## lines function changes y based on input$box.slider
  })
}

app <- shinyApp(ui = ui, server = server,options = list(height = 900,width = 1000))
app
```

<div style = "font-size:6px;" >
&nbsp;
</div> 

##### **Here's a Couple of Clues:**

<div style = "font-size:2px;" >
&nbsp;
</div> 

 - You'll need to move/reorder the tabsetPanel functions.
 
 - You need to add a new sub-title and 2 new input controls within the second tab
 
    - More information regarding input widgets can be found in the [widget gallery](https://shiny.rstudio.com/gallery/widget-gallery.html) or from the [Shiny Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2016/01/shiny-cheatsheet.pdf).
 
 -  You'll need to adjust the style of the panel sub-title.
 
    - More information regarding styling via HTML tags can be found in the [tag glossary](https://shiny.rstudio.com/articles/tag-glossary.html).
 
 - You need to use the functions `boxplot` and `lines`. 
 
<div style = "font-size:6px;" >
&nbsp;
</div> 

##### **Here's the Answer:**

```{r ,eval=TRUE,fig.align="center",echo=FALSE}
library(shiny)

ui <- fluidPage(
  
  #tags$style(type="text/css", "#answer.code {white-space: post-wrap;}")
  
  # Title Panel: 
    passwordInput(inputId = "answer.pass", label = "", 
                  value = "",placeholder = "Enter Password for Answer"),
  
  textOutput(outputId = "answer.code",container = pre)
  
)

  server <-  function(input, output) {
    
    output$answer.code <- renderText({
      if(input$answer.pass == "Password") {
"
library(shiny)

dat <- data.frame(ID = as.numeric((CO2$Plant)),CO2)

ui <- fluidPage(
  
  # Title Panel: 
  titlePanel(
    p('Shiny Workshop Example - CO2 Uptake in Plants', style = 'font-size: 20px')
  ),
  
  ## we must move the tabsetPanel (and subsequent tabPanel) functions before the sidebarPanel in order to have changing sidePanels.
  ## If we wanted different titles, we place titlePanel insidetabsetPanel, too.
  tabsetPanel( 
    tabPanel(title = 'Scatter Plot',
             
             sidebarPanel(width = 3,
                          div(style = 'color:green; padding:0px 0px 150px 0px;', 
                          #padding is top, right, bottom, left

                              p('Data Controls', style = 'font-size: 15px; color:blue;'),           
                              
                              # Check box to give us the option whether to show all plants 
                              # or just the plant selected in the slider input below
                              checkboxInput(inputId = 'all.plants', label = 'Show All Plants', value = T),
                              
                              # Slider bar allows us to select which plant ID to plot
                              # This slider only works if the above checkboxInput is unchecked (see server.R code)
                              sliderInput(inputId = 'plant', label = 'Plant ID', min = min(dat$ID), 
                                          max = max(dat$ID), value = 1),  ## sets starting value at 1
                              
                              # This group check box let's us narrow which plant Types are plotted.
                              # checkboxGroupInput differs from checkboxInput by allowing multiple checks at once
                              checkboxGroupInput(inputId = 'type', label = 'Plant Type', choices = levels(dat$Type), 
                                                 selected = levels(dat$Type)), ## sets starting checks to all levels 
                              
                              # Radio buttons work similar to checkboxes, but result in strings/#'s instead of T/F. 
                              # They allow multiple options like checkboxGroupInputs. 
                              radioButtons(inputId = 'treat', label = 'Treatment', 
                                           choices = c(levels(dat$Treatment), 'Both'), selected = 'Both'),
                              
                              fluidRow(
                                div(style = 'color:red;',
                                    column(width = 6, offset = 0,
                                           selectInput(inputId = 'colorQ', label = 'Quebec Color', 
                                                        choices = palette(), selected = 'black')
                                    ),
                                    column(width = 6, offset = 0,
                                           selectInput(inputId = 'colorM', label = 'Miss. Color',
                                                        choices = palette(), selected = 'black') 
                                    )
                                )
                              ),
                              ## We'll insert printed R output generated from clicking the plot
                              ## Note: this text is created using nearPoints() in server.R
                              verbatimTextOutput(outputId = 'plot.info')
                              
                          )
             ),
             
             mainPanel(width = 9,
                       plotOutput(outputId = 'plot',click = 'plot.click'), ## scatter plot
                       dataTableOutput(outputId = 'data') ## data table 
             )
             
    ),
    
    ## Create 2nd tab:
    tabPanel(title = 'Box Plot',
             
             ## Add subtitle using paragraph HTML tag helper function:
             p('Box Plot Viewer',style = 'font-size:18px;'),
             
             ## Set up new sidebarPanel
             sidebarPanel(width = 3,
                          
                          ## Provide sidebarPanel title:
                          p('Box Plot Controls', style = 'color:purple'),
                          
                          ## Add input selector to choose which x variable is plotted:
                          radioButtons(inputId = 'box.plot.chooser', label = 'X Variable', 
                                       choices = names(CO2)[names(CO2) != 'uptake'], selected = 'Type'),
                          
                          ## Add slider input that dictates which y value a 'moveable' horizontal line is located:
                          sliderInput(inputId = 'box.slider', label = 'Comparison Aid', min = 0, 
                                      max = max(CO2$uptake), value = 0)
                          
             ),
             ## Set up new mainPanel for this 2nd tab:
             mainPanel(width = 9,
                       plotOutput(outputId = 'boxplot')
             )
             
    )
  )
)

server <- function(input, output) {
  
  # We need to Set-up various input values:
  
  ## Allows us to narrow data by one plant or to include all plants. 
  ## This is necessary b/c checkboxInput simply generates T/F, and we must translate that to plant ID #'s. 
  plants.to.plot <- reactive({ 
    if(input$all.plants == T) {
      sort(unique(dat$ID))
    } else { input$plant
    }
  })
  
  ## Allows us to narrow data by one treatment level or to include both. 
  ## This is necessary because 'both' is not actually a Treatment type, ... 
  ## ...and therefore needs to be assigned something meaningful (i.e., relevant to the data)
  treats.to.plot <- reactive({ 
    if(input$treat == 'Both') {
      levels(dat$Treatment)
    } else {input$treat
    }
  }) 
  
  ## provides vector of color options (corresponding to plant$Type) to apply to coloring points in plot
  colors <- reactive({
    Colors <- rep(NA,length(dat2()$Type))
    Colors[which(dat2()$Type == 'Quebec')] <- input$colorQ
    Colors[which(dat2()$Type == 'Mississippi')] <- input$colorM
    Colors
  })   
  
  # Create modified data set based on our numerous input selections:
  ## This will keep our plotting code neater...
  
  dat2 <- reactive({  dat[dat$ID %in% c(plants.to.plot()) &
                            dat$Type  %in% c(input$type) &
                            dat$Treatment %in% c(treats.to.plot()), ] 
  })
  
  
  # Create plot to be rendered in mainpanel. Notice we now use dat2 as the data source. 
  
  output$scatter.plot <- renderPlot({
    plot(uptake ~ conc, data = dat, type = 'n')
    points(uptake ~ conc, data = dat2(),col = colors())
    title(main = paste0('Plant(s): ', paste(levels(dat$Plant)[plants.to.plot()],collapse =', ')))
    ## title combines 'Plant(s)' with the plant names of whichever plants are included by the inputs. 
  })
  
  
  # Create data.frame showing data of only the plants (i.e. the rows) selected to be plotted
  
  output$data <- renderDataTable({ dat2()},
                                 options = list(lengthMenu = list(c(5, 10,-1), list('5', '10', 'All')), 
                                                pageLength = 5, ordering = T))
  ## These options allow for modification of the data table presented.
  ## This is a rare case in which UI formatting is assigned in server.R code
  ## lengthMenu creates drop down menu giving you choice in # of rows to show.
  ## (-1 = show all rows)
  ## pageLength assigns how many rows are shown when table is 1st rendered
  ## ordering allows you to click on columns to change ordering of the data.
  
  
  # Create data to be generated when the scatter plot is clicked 
  
  #Update to make plot clicker info look better:
  nearPoints2 <- function(coordinfo,blank.text = 'Click on Plot Points for Details', cols, ...) {
    if (is.null(coordinfo)) {
      cat(blank.text,'\\n')   #'Click on Plot Points for Details'
    } else { 
      points.info.table <- nearPoints(coordinfo = coordinfo,...)
      print(points.info.table[,cols], row.names = F)
    }
  }
  
  #Create table containing columns 2:6 of dat2 for the point clicked and assign to renderPrint output:
  output$plot.info <- renderPrint({
    nearPoints2(coordinfo = input$plot.click, cols = c(2:6), df = dat2(), xvar = 'conc', 
                yvar = 'uptake',threshold=3)
  })  ## Note: nearPoints (default or nP2) actually reports all points (i.e., rows in your data.frame)  
  ## that are within the threshold value distance from your click. 
  ## So you might want to shrink `threshold` if your clicks result in too many data.  
  
  ###############
  
  ##Here is the added boxplot code. 
  
  output$boxplot <- renderPlot({
    
    ## I want the boxplot function to plot different x variables, which are input as character strings
    ## character strings need to be slightly modified to be included in a plotting function
    ## One option: x = get(paste('CO2',input$box.plot.chooser),sep='$')
    ## I instead choose to go with the as.formula approach:
    
    boxplot(as.formula(paste('uptake',input$box.plot.chooser, sep = ' ~ ')), data = CO2, 
            xlab = input$box.plot.chooser, ylab = 'uptake')
    lines(x = c(0:15), y = rep(input$box.slider,16), lty = 6)  ##lines function changes y based on input$box.slider
  })

}

app <- shinyApp(ui = ui, server = server)
app
"
}
})
}

shinyApp(ui = ui, server = server,options = list(width = 1000))
    
```


<div style = "font-size:6px;" >
&nbsp;
</div> 

***
 
<div style = "font-size:2px;" >
&nbsp;
</div> 
 
#### **Sharing Your Shiny App**
 
<div style = "font-size:2px;" >
&nbsp;
</div> 

Once you have completed an app, you can share it with your colleagues in several ways. The easiest way is
to send them the code (server.R and ui.R file(s)). However, you can also host the code online so that it can be run
from anyone using R without the files. 

For example, [Github](https://github.com/rstudio/shiny-server) can host the code. RStudio likewise provides options for hosting Shiny apps. They can host your app(s) in RStudio's dedicated [Shiny Server](https://www.rstudio.com/products/shiny/shiny-server/), or they can help you host your app(s) on the cloud with [ShinyApps.io](https://www.shinyapps.io/). 

  - ShinyApps.io is free for the first 5 apps (and up to 25 user "active" hours per month).

Hosting Shiny apps is beyond the scope of this intro workshop, so I will leave learning more about that aspect of this process up to you. See [here](https://shiny.rstudio.com/deploy/) for more information. 

<div style = "font-size:1px;" >
&nbsp;
</div> 


***

<div style = "font-size:1px;" >
&nbsp;
</div>

### **Further Reading and Useful Resources**

<div style = "font-size:1px;" >
&nbsp;
</div>

  **Learning Resources**
  
  1. Shiny Cheat Sheet: https://www.rstudio.com/wp-content/uploads/2016/01/shiny-cheatsheet.pdf
  
  2. Widget Gallery: https://shiny.rstudio.com/gallery/widget-gallery.html
  
  3. HTML Tag Glossary https://shiny.rstudio.com/articles/tag-glossary.html
  
  4. Tutorials: https://shiny.rstudio.com/tutorial/
  
  5. Example Apps: https://www.rstudio.com/products/shiny/shiny-user-showcase/

<div style = "font-size:1px;" >
&nbsp;
</div>

  **Shiny App Deployment & Sharing:**
  
  1. Deployment Guidance: https://shiny.rstudio.com/deploy/
  
  2. Github Shiny Server: https://github.com/rstudio/shiny-server
  
  3. RStudio's Shiny Server: https://www.rstudio.com/products/shiny/shiny-server/
  
  4. ShinyApps.io: https://www.shinyapps.io/

<div style = "font-size:1px;" >
&nbsp;
</div>

***
<div style = "font-size:12px;" > 
&copy; Chris Payne 2017. \      This document was generated using: RStudio version 1.0.136 and R version 3.3.2 with packages shiny 1.0.1 | rmarkdown 1.4 | knitr 1.15.1 
</div>